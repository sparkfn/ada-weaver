<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Deep Agents Dialog</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
      background: #1a1a2e;
      color: #e0e0e0;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 12px 20px;
      background: #16213e;
      border-bottom: 1px solid #0f3460;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    header h1 { font-size: 16px; font-weight: 600; }
    header .session {
      font-size: 11px;
      color: #888;
      margin-left: auto;
      font-family: monospace;
    }

    #messages {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .msg {
      max-width: 80%;
      padding: 10px 14px;
      border-radius: 8px;
      line-height: 1.5;
      white-space: pre-wrap;
      word-break: break-word;
      font-size: 14px;
    }

    .msg.user {
      align-self: flex-end;
      background: #0f3460;
      color: #e0e0e0;
    }

    .msg.agent {
      align-self: flex-start;
      background: #16213e;
      border: 1px solid #0f3460;
    }

    .msg.error {
      align-self: center;
      background: #3d0000;
      border: 1px solid #6b0000;
      color: #ff6b6b;
      font-size: 12px;
    }

    .msg.thinking-status {
      align-self: flex-start;
      background: transparent;
      color: #888;
      font-style: italic;
      padding: 4px 14px;
      font-size: 13px;
    }

    /* Thinking block — collapsible tool calls */
    .thinking-block {
      align-self: flex-start;
      max-width: 80%;
      font-size: 12px;
    }

    .thinking-block summary {
      cursor: pointer;
      color: #7b6ba0;
      padding: 4px 0;
      user-select: none;
    }

    .thinking-block summary:hover { color: #a98edb; }

    .thinking-steps {
      margin-top: 4px;
      padding: 8px 12px;
      background: #111128;
      border: 1px solid #2a2a4a;
      border-radius: 6px;
      max-height: 300px;
      overflow-y: auto;
    }

    .tool-step {
      padding: 4px 0;
      border-bottom: 1px solid #1e1e3a;
      font-family: monospace;
      font-size: 11px;
      color: #aaa;
    }

    .tool-step:last-child { border-bottom: none; }

    .tool-step .tool-name {
      color: #a98edb;
      font-weight: 600;
    }

    .tool-step .tool-args {
      color: #6b8fb5;
      margin-left: 8px;
    }

    .tool-step .tool-result {
      color: #6b9b6b;
      display: block;
      margin-top: 2px;
      white-space: pre-wrap;
      max-height: 100px;
      overflow-y: auto;
    }

    /* Token usage badge */
    .usage-badge {
      align-self: flex-start;
      font-size: 11px;
      color: #666;
      padding: 2px 8px;
      font-family: monospace;
    }

    #input-area {
      padding: 12px 20px;
      background: #16213e;
      border-top: 1px solid #0f3460;
      display: flex;
      gap: 8px;
    }

    #input {
      flex: 1;
      padding: 10px 14px;
      background: #1a1a2e;
      border: 1px solid #0f3460;
      border-radius: 6px;
      color: #e0e0e0;
      font-size: 14px;
      font-family: inherit;
      outline: none;
      resize: none;
    }

    #input:focus { border-color: #533483; }

    #send {
      padding: 10px 20px;
      background: #533483;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-family: inherit;
    }

    #send:hover { background: #6b44a0; }
    #send:disabled { background: #333; cursor: not-allowed; }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }
    .pulsing { animation: pulse 1.5s infinite; }
  </style>
</head>
<body>
  <header>
    <h1>Deep Agents Dialog</h1>
    <span class="session" id="session-display"></span>
  </header>

  <div id="messages"></div>

  <div id="input-area">
    <textarea id="input" rows="1" placeholder="Ask about the codebase..." autofocus></textarea>
    <button id="send">Send</button>
  </div>

  <script>
    const sessionId = crypto.randomUUID();
    document.getElementById('session-display').textContent = 'session: ' + sessionId.slice(0, 8);

    const messagesEl = document.getElementById('messages');
    const inputEl = document.getElementById('input');
    const sendBtn = document.getElementById('send');

    function addElement(html, cls) {
      const div = document.createElement('div');
      if (cls) div.className = cls;
      div.innerHTML = html;
      messagesEl.appendChild(div);
      messagesEl.scrollTop = messagesEl.scrollHeight;
      return div;
    }

    function addMessage(text, cls) {
      const div = document.createElement('div');
      div.className = 'msg ' + cls;
      div.textContent = text;
      messagesEl.appendChild(div);
      messagesEl.scrollTop = messagesEl.scrollHeight;
      return div;
    }

    function escapeHtml(s) {
      return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }

    async function send() {
      const message = inputEl.value.trim();
      if (!message) return;

      inputEl.value = '';
      inputEl.style.height = 'auto';
      addMessage(message, 'user');

      sendBtn.disabled = true;
      const statusEl = addMessage('Thinking...', 'thinking-status pulsing');

      // Thinking block — collects tool calls
      let thinkingEl = null;
      let stepsEl = null;
      let toolCount = 0;

      function ensureThinkingBlock() {
        if (thinkingEl) return;
        thinkingEl = addElement(
          '<details open><summary>Thinking...</summary><div class="thinking-steps"></div></details>',
          'thinking-block'
        );
        stepsEl = thinkingEl.querySelector('.thinking-steps');
      }

      function addToolStep(html) {
        ensureThinkingBlock();
        const step = document.createElement('div');
        step.className = 'tool-step';
        step.innerHTML = html;
        stepsEl.appendChild(step);
        messagesEl.scrollTop = messagesEl.scrollHeight;
      }

      function updateThinkingSummary() {
        if (!thinkingEl) return;
        const summary = thinkingEl.querySelector('summary');
        summary.textContent = `Thinking (${toolCount} tool call${toolCount !== 1 ? 's' : ''})`;
      }

      // Track active tool calls to match start/end
      const activeTools = new Map();

      try {
        const res = await fetch('/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ message, sessionId }),
        });

        if (!res.ok) {
          statusEl.remove();
          const err = await res.json().catch(() => ({ error: res.statusText }));
          addMessage('Error: ' + (err.error || res.statusText), 'error');
          return;
        }

        // Read SSE stream
        const reader = res.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop(); // keep incomplete line in buffer

          for (const line of lines) {
            if (!line.startsWith('data: ')) continue;
            const data = line.slice(6);
            if (data === '[DONE]') continue;

            let event;
            try { event = JSON.parse(data); } catch { continue; }

            if (event.type === 'tool_start') {
              toolCount++;
              const argsStr = event.args ? JSON.stringify(event.args) : '';
              const shortArgs = argsStr.length > 120 ? argsStr.slice(0, 120) + '...' : argsStr;
              addToolStep(
                `<span class="tool-name">${escapeHtml(event.name || '?')}</span>` +
                `<span class="tool-args">${escapeHtml(shortArgs)}</span>`
              );
              statusEl.textContent = `Calling ${event.name}...`;
              updateThinkingSummary();
            } else if (event.type === 'tool_end') {
              const result = event.result || '';
              const shortResult = result.length > 300 ? result.slice(0, 300) + '...' : result;
              // Append result to the last tool step
              if (stepsEl && stepsEl.lastChild) {
                const resultSpan = document.createElement('span');
                resultSpan.className = 'tool-result';
                resultSpan.textContent = shortResult;
                stepsEl.lastChild.appendChild(resultSpan);
              }
              statusEl.textContent = 'Thinking...';
              messagesEl.scrollTop = messagesEl.scrollHeight;
            } else if (event.type === 'response') {
              statusEl.remove();
              addMessage(event.text || '(empty response)', 'agent');
            } else if (event.type === 'usage') {
              const t = event.tokens || {};
              addElement(
                `tokens: ${(t.input||0).toLocaleString()} in / ${(t.output||0).toLocaleString()} out / ${(t.total||0).toLocaleString()} total`,
                'usage-badge'
              );
            } else if (event.type === 'error') {
              statusEl.remove();
              addMessage('Error: ' + (event.message || 'Unknown error'), 'error');
            }
          }
        }

        // If status element is still there (no response event), remove it
        if (statusEl.parentNode) statusEl.remove();

        // Collapse thinking block after response arrives
        if (thinkingEl) {
          const details = thinkingEl.querySelector('details');
          if (details) details.open = false;
        }

      } catch (err) {
        if (statusEl.parentNode) statusEl.remove();
        addMessage('Network error: ' + err.message, 'error');
      } finally {
        sendBtn.disabled = false;
        inputEl.focus();
      }
    }

    sendBtn.addEventListener('click', send);

    inputEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        send();
      }
    });

    // Auto-resize textarea
    inputEl.addEventListener('input', () => {
      inputEl.style.height = 'auto';
      inputEl.style.height = Math.min(inputEl.scrollHeight, 120) + 'px';
    });
  </script>
</body>
</html>
